import Foundation

/// Tic-tac-toe game algorithm
/// taken from https://www.baeldung.com/cs/tic-tac-toe-winning-combinations
/// Code generated by ChatGPT from above algorithm!
final class TicTacToe: Codable {
    typealias Board = [[Player]]

    enum Player: String, Codable {
        case none
        case x
        case o

        func next() -> Player {
            self == .x ? .o : .x
        }
    }

    enum GameState: Codable {
        case ongoing
        case draw
        case win(Player)

        func didWin(_ player: Player) -> Bool {
            if case let .win(side) = self {
                return side == player
            }
            return false
        }

        var didDraw: Bool {
            if case .draw = self { true } else { false }
        }

        var hasEnded: Bool {
            if case .ongoing = self { false } else { true }
        }
    }

    let size: Int
    var board: Board
    var turn: Player

    init(size: Int = 3) {
        self.size = size
        self.board = Array(repeating: Array(repeating: .none, count: size), count: size)
        self.turn = .x
    }
}

extension TicTacToe {
    func isEmpty() -> Bool {
        board.flatMap { $0 }.allSatisfy { $0 == .none }
    }

    func checkWin() -> GameState {
        for i in 0..<size {
            // Check rows
            if board[i][0] != .none && (0..<size).allSatisfy({ board[i][$0] == board[i][0] }) {
                return .win(board[i][0])
            }
            // Check columns
            if board[0][i] != .none && (0..<size).allSatisfy({ board[$0][i] == board[0][i] }) {
                return .win(board[0][i])
            }
        }

        // Check diagonal (top-left to bottom-right)
        if board[0][0] != .none && (0..<size).allSatisfy({ board[$0][$0] == board[0][0] }) {
            return .win(board[0][0])
        }

        // Check diagonal (top-right to bottom-left)
        if board[0][size - 1] != .none && (0..<size).allSatisfy({ board[$0][size - 1 - $0] == board[0][size - 1] }) {
            return .win(board[0][size - 1])
        }

        // Check for draw or ongoing
        if board.flatMap({ $0 }).contains(.none) {
            return .ongoing
        } else {
            return .draw
        }
    }

    func makeMove(row: Int, col: Int, player: Player) -> Bool {
        if player != turn {
            return false
        }
        if board[row][col] == .none {
            board[row][col] = player
            turn = turn.next()
            return true
        }
        return false
    }

    func leave(player: Player) -> GameState {
        let state = checkWin()
        switch state {
        case .ongoing:
            if isEmpty() { return .draw }
            return .win(player == .x ? .o : .x)
        default:
            return state
        }
    }

    func printBoard() {
        for row in board {
            for cell in row {
                switch cell {
                case .none:
                    print("-", terminator: " ")
                case .x:
                    print("X", terminator: " ")
                case .o:
                    print("O", terminator: " ")
                }
            }
            print()
        }
    }
}

// Example usage:
// let game = TicTacToe()
// game.makeMove(row: 0, col: 0, player: .x)
// game.makeMove(row: 0, col: 1, player: .x)
// game.makeMove(row: 0, col: 2, player: .x)
// game.printBoard()
// print(game.checkWin())
